# core/manim_diagram_generator.py
import os
import json
import re
import tempfile
import shutil
import time
from typing import Dict, Any, List, Optional

# Attempt to import manim
try:
    # Use the newer API if available (Manim Community v0.12.0+)
    from manim import (
        Scene, Circle, Square, Ellipse, VGroup, Text, Arrow, DashedLine,
        RIGHT, UP, BLACK, RED, config, tempconfig, ManimColor,
        __version__ as manim_version,
        PI # Import PI for diamond rotation
    )
    MANIM_AVAILABLE = True
    print(f"Manim imported successfully (version: {manim_version}).")
except ImportError:
    MANIM_AVAILABLE = False
    print("Manim not installed or not accessible. Manim diagram generation will be disabled.")
    # Define dummy classes/objects if Manim is not available
    class Scene: pass
    class Mobject: pass
    class VGroup(Mobject): pass
    class Text(Mobject): pass
    class Arrow(Mobject): pass
    class DashedLine(Mobject): pass
    class Circle(Mobject): pass
    class Square(Mobject): pass
    class Ellipse(Mobject): pass
    RIGHT = UP = BLACK = RED = object()
    config = object()
    tempconfig = lambda x: lambda f: f # Dummy decorator
    ManimColor = str
    PI = 3.14159 # Dummy PI


class ManimDiagramGenerator:
    """
    Generates block diagrams using Manim based on structured descriptions
    generated by a Groq LLM. Renders locally and provides image file paths.
    """

    def __init__(self, groq_client, groq_model):
        """
        Initializes the ManimDiagramGenerator.

        Args:
            groq_client: An initialized Groq client instance.
            groq_model: The Groq model name to use for generating diagram descriptions.
        """
        if not MANIM_AVAILABLE:
            print("Manim is not available. This generator cannot be used.")
            self.groq_client = None # Disable functionality
            self.groq_model = None
            self.temp_dir = None
            return

        self.groq_client = groq_client
        self.groq_model = groq_model
        # Create a persistent temporary directory for Manim output for this generator instance
        # Manim's tempconfig handles per-render output, but this keeps related renders grouped.
        self.temp_dir = tempfile.mkdtemp(prefix="manim_gen_")
        print(f"ManimDiagramGenerator initialized. Temp directory: {self.temp_dir}")

        # Validate Groq client
        if not self.groq_client:
             print("Groq client not provided. LLM-based diagram structure generation will not work.")


    def generate_diagram_structure(self, slide_title: str, topic: str, complexity_level: str) -> Optional[Dict[str, Any]]:
        """
        Uses the Groq LLM to generate a structured JSON description
        for a block diagram.

        Args:
            slide_title: The title of the slide needing a diagram.
            topic: The overall topic of the presentation.
            complexity_level: The target audience complexity.

        Returns:
            A dictionary containing the diagram structure, or None if generation fails.
        """
        if not self.groq_client:
            print("Groq client not initialized. Cannot generate diagram structure.")
            return None

        # --- LLM Prompt for Structured Diagram Data ---
        # Prompt refined slightly for clarity and focus on structure.
        prompt = f"""
        Generate a JSON text description for a block diagram that visually explains the concept: "{slide_title}".
        The diagram should be suitable for a {complexity_level.lower()} level lecture on "{topic}".

        Provide a structure including nodes and connections.
        Nodes should have:
        - "id" (string, unique identifier)
        - "label" (string, text displayed in the node)
        - "shape" (string, e.g., "rectangle", "circle", "diamond", "database")
        - "color" (string, a common color name or hex code, e.g., "Blue", "#34A853")
        - "position" (string, optional, a hint for layout like "left", "right", "top", "bottom", "center" - will be used for arranging).

        Connections should have:
        - "from" (string, id of the source node)
        - "to" (string, id of the target node)
        - "label" (string, optional, text on the arrow)
        - "style" (string, optional, e.g., "arrow", "dashed_arrow").

        Aim for a clear and professional layout. Limit the number of nodes and connections to keep the diagram simple for a lecture slide.

        Your response MUST follow these rules STRICTLY:
        1. Provide ONLY JSON output strictly between START OF JSON and END OF JSON markers. Do NOT include any text before START OF JSON or after END OF JSON.
        2. The JSON MUST be a valid JSON object with two keys: "nodes" (a list of node objects) and "connections" (a list of connection objects).
        3. Ensure all strings use double quotes and special characters are escaped.

        Example JSON structure:
        ```
        START OF JSON
        {{
            "nodes": [
                {{"id": "A", "label": "Input", "shape": "rectangle", "color": "Blue", "position": "left"}},
                {{"id": "B", "label": "Processing", "shape": "rectangle", "color": "Green", "position": "center"}},
                {{"id": "C", "label": "Output", "shape": "rectangle", "color": "Red", "position": "right"}}
            ],
            "connections": [
                {{"from": "A", "to": "B", "label": "Send Data", "style": "arrow"}},
                {{"from": "B", "to": "C", "label": "Result", "style": "arrow"}}
            ]
        }}
        END OF JSON
        ```

        Generate the JSON structure for the concept: "{slide_title}" within the context of "{topic}".
        """
        # --- End of Prompt ---

        print(f"ManimGen: Calling Groq for diagram structure for: {slide_title}")
        try:
            response = self.groq_client.chat.completions.create(
                messages=[{"role": "user", "content": prompt}],
                model=self.groq_model,
                max_tokens=1000,
                temperature=0.5
            )
            raw_response_text = response.choices[0].message.content.strip()
            print("ManimGen: Received response from Groq for diagram structure.")
            # print(f"DEBUG Raw LLM response snippet:\n{raw_response_text[:500]}...") # Optional Debug

            # Extract JSON using regex
            json_match = re.search(r'START OF JSON\s*([\s\S]*?)\s*END OF JSON', raw_response_text, re.DOTALL)
            if json_match:
                json_text = json_match.group(1).strip()
                # print("DEBUG Extracted JSON between markers.")
            else:
                 # Fallback if markers are missing - try to find the first {.*} or [.*]
                 json_text = raw_response_text.strip()
                 # print("DEBUG Markers not found, trying to find JSON pattern.")
                 object_match = re.search(r'({.*})', json_text, re.DOTALL)
                 if object_match:
                     json_text = object_match.group(1).strip()
                     # print("DEBUG Found JSON object pattern.")
                 else:
                      array_match = re.search(r'(\[[\s\S]*\])', json_text, re.DOTALL)
                      if array_match:
                         json_text = array_match.group(1).strip()
                         # print("DEBUG Found JSON array pattern.")
                      else:
                          print("ManimGen: Could not find JSON structure in LLM response.")
                          return None


            try:
                diagram_structure = json.loads(json_text)
                print("ManimGen: Parsed diagram structure JSON successfully.")
                # Validate basic structure
                if isinstance(diagram_structure, dict) and 'nodes' in diagram_structure and 'connections' in diagram_structure:
                     if isinstance(diagram_structure['nodes'], list) and isinstance(diagram_structure['connections'], list):
                        print(f"ManimGen: Structure contains {len(diagram_structure['nodes'])} nodes and {len(diagram_structure['connections'])} connections.")
                        return diagram_structure
                     else:
                        print("ManimGen: JSON structure invalid: 'nodes' or 'connections' is not a list.")
                        return None
                else:
                    print("ManimGen: JSON structure invalid: missing 'nodes' or 'connections' keys.")
                    return None

            except json.JSONDecodeError as e:
                print(f"ManimGen: Error decoding JSON from LLM response: {e}")
                print(f"DEBUG Problematic JSON text snippet:\n{json_text[:500]}...")
                return None

        except Exception as e:
            print(f"ManimGen: Error generating or parsing diagram structure with Groq: {e}")
            return None


    def build_manim_scene(self, diagram_structure: Dict[str, Any]) -> Optional[Scene]:
        """
        Builds a Manim Scene object from a structured diagram description.

        Args:
            diagram_structure: A dictionary containing 'nodes' and 'connections'.

        Returns:
            A Manim Scene object or None if structure is invalid/unbuildable.
        """
        if not MANIM_AVAILABLE:
             print("ManimGen: Manim not available. Cannot build scene.")
             return None

        if not isinstance(diagram_structure, dict) or 'nodes' not in diagram_structure or 'connections' not in diagram_structure:
            print("ManimGen: Invalid diagram structure provided to build_manim_scene.")
            return None

        nodes_data: List[Dict[str, Any]] = diagram_structure.get('nodes', [])
        connections_data: List[Dict[str, Any]] = diagram_structure.get('connections', [])

        # Define a simple scene class dynamically
        # Using a simple class name for Manim's internal file path logic
        class _GeneratedDiagramScene(Scene):
            def construct(self):
                node_mobjects: Dict[str, VGroup] = {}
                mobjects_to_arrange = [] # List of mobjects to arrange automatically

                # Create Manim Mobjects for nodes
                for i, node in enumerate(nodes_data):
                    node_id = node.get('id', f'node_{i}')
                    label_text = str(node.get('label', node_id))
                    shape_type = str(node.get('shape', 'rectangle')).lower()
                    color_name = str(node.get('color', 'Gray'))
                    position_hint = str(node.get('position', 'center')).lower()

                    # Basic validation for color
                    try:
                        fill_color = ManimColor(color_name)
                    except ValueError:
                        print(f"ManimGen: Invalid color '{color_name}' for node '{node_id}'. Using Gray.")
                        fill_color = ManimColor("Gray")


                    # Map shape strings to Manim shapes (simplified)
                    if shape_type == 'circle':
                        shape_mobj = Circle(fill_opacity=0.8, fill_color=fill_color, stroke_color=BLACK)
                    elif shape_type == 'database':
                         shape_mobj = Ellipse(width=2.5, height=1.5, fill_opacity=0.8, fill_color=fill_color, stroke_color=BLACK) # Simple representation
                    elif shape_type == 'diamond':
                         # Create a square and rotate it for a diamond shape
                         shape_mobj = Square(side_length=2.0).rotate(PI/4).set_fill(fill_color, opacity=0.8).set_stroke(BLACK)
                    else: # Default to rectangle (using Square for simplicity with text)
                        shape_mobj = Square(side_length=2.5, fill_opacity=0.8, fill_color=fill_color, stroke_color=BLACK)

                    # Add label
                    # Ensure text fits within the shape if possible (basic scaling/wrapping)
                    text_mobj = Text(label_text, font_size=30, color=BLACK)
                    # Simple scaling heuristic: if text is too wide, scale it down
                    if text_mobj.width > shape_mobj.width * 0.8:
                         text_mobj.scale_to_fit_width(shape_mobj.width * 0.8)
                    # More advanced wrapping would be complex

                    # Group shape and text
                    node_mobj = VGroup(shape_mobj, text_mobj)
                    node_mobjects[node_id] = node_mobj
                    mobjects_to_arrange.append(node_mobj)


                # --- Simple Automatic Layout ---
                # Arrange nodes based on number or hints (hints not fully implemented in this basic layout)
                if mobjects_to_arrange:
                    # Simple horizontal arrangement as a default
                    VGroup(*mobjects_to_arrange).arrange(RIGHT, buff=1.5).move_to(ORIGIN)

                    # Could add more complex layout based on position hints here
                    # E.g., group nodes by hint ("left", "right") and arrange groups

                    self.add(*mobjects_to_arrange) # Add all node VGroups to the scene
                else:
                    # Add placeholder text if no nodes were created
                    self.add(Text("Could not generate diagram elements", font_size=48, color=RED))
                    print("ManimGen: No valid nodes created for the diagram.")
                    return self # Return scene even if empty or error message added

                # Create Manim Mobjects for connections (arrows)
                # Need to iterate AFTER all nodes are added and positioned by arrange
                for conn in connections_data:
                    from_id = conn.get('from')
                    to_id = conn.get('to')
                    conn_label = str(conn.get('label', ''))
                    conn_style = str(conn.get('style', 'arrow')).lower()

                    if from_id in node_mobjects and to_id in node_mobjects:
                        start_mobj = node_mobjects[from_id]
                        end_mobj = node_mobjects[to_id]

                        # Determine connection points intelligently based on relative positions
                        # This is a very basic approach; for general graphs, layout is key.
                        # If 'to' is to the right of 'from', connect right to left.
                        # If 'to' is below 'from', connect bottom to top, etc.
                        start_point = start_mobj.get_center()
                        end_point = end_mobj.get_center()

                        if end_point[0] > start_point[0]: # Target is right
                            conn_start = start_mobj.get_right()
                            conn_end = end_mobj.get_left()
                        elif end_point[0] < start_point[0]: # Target is left
                            conn_start = start_mobj.get_left()
                            conn_end = end_mobj.get_right()
                        elif end_point[1] > start_point[1]: # Target is up
                            conn_start = start_mobj.get_top()
                            conn_end = end_mobj.get_bottom()
                        elif end_point[1] < start_point[1]: # Target is down
                            conn_start = start_mobj.get_bottom()
                            conn_end = end_mobj.get_top()
                        else: # Same position? Or diagonal - default to right-to-left
                            conn_start = start_mobj.get_right()
                            conn_end = end_mobj.get_left()


                        if conn_style == 'dashed_arrow':
                            arrow = DashedLine(conn_start, conn_end, buff=0.1, color=BLACK).add_tip()
                        else: # Default to solid arrow
                             arrow = Arrow(conn_start, conn_end, buff=0.1, color=BLACK)

                        if conn_label:
                             label_mobj = Text(conn_label, font_size=20, color=BLACK)
                             # Position label near the middle of the arrow
                             label_mobj.move_to((conn_start + conn_end) / 2)
                             # Adjust label position slightly based on arrow direction (simplified)
                             if abs(conn_start[0] - conn_end[0]) > abs(conn_start[1] - conn_end[1]): # Mostly horizontal
                                 label_mobj.shift(UP * 0.2) # Shift up
                             else: # Mostly vertical or diagonal
                                 label_mobj.shift(RIGHT * 0.2) # Shift right
                             arrow = VGroup(arrow, label_mobj) # Group arrow and label

                        self.add(arrow)
                    else:
                        print(f"ManimGen: Warning: Connection from '{from_id}' to '{to_id}' refers to non-existent nodes.")

        # Instantiate and return the dynamically created scene
        return _GeneratedDiagramScene()


    def render_scene_to_png(self, scene: Scene, output_file_name_base: str = "diagram_output") -> Optional[str]:
        """
        Renders a Manim scene to a PNG image file locally using tempconfig.

        Args:
            scene: The Manim Scene object to render.
            output_file_name_base: Base name for the output file (without extension).

        Returns:
            The full path to the generated PNG file, or None on failure.
        """
        if not MANIM_AVAILABLE:
             print("ManimGen: Manim not available. Cannot render scene.")
             return None

        if not isinstance(scene, Scene):
             print("ManimGen: Provided object is not a valid Manim scene.")
             return None

        if self.temp_dir is None or not os.path.exists(self.temp_dir):
             print("ManimGen: Temporary directory not initialized or found. Cannot render.")
             return None

        # Use tempconfig to manage output for this render job
        # This creates a temporary directory structure within the specified media_dir
        # and cleans it up after the block, unless keep_original_media_dir is True (which we don't want here)
        output_qualities = ["medium_quality", "low_quality"] # Try medium first, then low
        output_path = None

        for quality in output_qualities:
            try:
                print(f"ManimGen: Attempting render with quality '{quality}'...")
                with tempconfig({
                    "media_dir": self.temp_dir,
                    "quality": quality,
                    "renderer": "cairo",       # Use Cairo for static images
                    "save_last_frame": True,   # Save the final frame
                    "output_file": output_file_name_base, # Set the output file base name
                    "transparent": True # Optional: make background transparent
                    # "format": "png" # Should be implicit with renderer="cairo" and save_last_frame=True
                }):
                    # Perform the render. Manim saves the file automatically.
                    # The render() method might raise an exception on failure.
                    scene.render()

                # Manim saves output in a specific structure:
                # media_dir/images/SceneClassName/quality/output_file_name.png
                # The scene class name will be '_GeneratedDiagramScene'
                expected_output_dir = os.path.join(
                    self.temp_dir,
                    "images",
                    scene.__class__.__name__, # Use the actual class name
                    quality
                )
                expected_file_name = f"{output_file_name_base}.png"
                potential_output_path = os.path.join(expected_output_dir, expected_file_name)

                if os.path.exists(potential_output_path):
                    print(f"ManimGen: Successfully rendered and found image at: {potential_output_path}")
                    output_path = potential_output_path
                    break # Found the file, exit quality loop
                else:
                    print(f"ManimGen: Rendered with quality '{quality}' but output file not found at expected path: {potential_output_path}")

            except Exception as e:
                print(f"ManimGen: Error during Manim render with quality '{quality}': {e}")
                # Cleanup potential partial output from this failed render attempt
                render_output_dir = os.path.join(
                    self.temp_dir,
                    "images",
                    scene.__class__.__name__,
                    quality
                )
                if os.path.exists(render_output_dir):
                     shutil.rmtree(render_output_dir, ignore_errors=True)


        if output_path and os.path.exists(output_path):
             # Move the generated file to the root of the temp directory for easier access
             final_output_path = os.path.join(self.temp_dir, f"{output_file_name_base}.png")
             try:
                 shutil.move(output_path, final_output_path)
                 print(f"ManimGen: Moved final image to: {final_output_path}")
                 # tempconfig *should* clean up the intermediate structure, but doing move ensures it's in a known place
                 return final_output_path
             except Exception as e:
                 print(f"ManimGen: Error moving final file: {e}. Returning original path.")
                 return output_path # Return the original path if move fails
        else:
            print("ManimGen: Failed to render and find the output image after trying all qualities.")
            return None


    def generate_and_get_path(self, slide_title: str, topic: str, complexity_level: str) -> Optional[str]:
        """
        Generates a diagram using Manim, renders it, and returns the local file path.

        Args:
            slide_title: The title of the slide needing a diagram.
            topic: The overall topic of the presentation.
            complexity_level: The target audience complexity level.

        Returns:
            The full path to the generated PNG file, or None on failure.
        """
        if not MANIM_AVAILABLE or not self.groq_client:
             print("ManimGen: Manim not available or Groq client missing. Cannot generate diagram.")
             return None

        print(f"ManimGen: Attempting to generate Manim diagram for: {slide_title}")

        # 1. Generate structured data from LLM
        diagram_structure = self.generate_diagram_structure(
            slide_title, topic, complexity_level
        )

        if not diagram_structure:
            print("ManimGen: Failed to generate diagram structure from LLM.")
            return None

        # 2. Build Manim scene programmatically from structure
        scene = self.build_manim_scene(diagram_structure)

        if not scene:
            print("ManimGen: Failed to build Manim scene from structure.")
            return None

        # 3. Render the scene to a PNG file
        # Create a safe and unique base name for the output file
        output_base_name_safe = re.sub(r'[^\w\-_\.]', '_', slide_title).lower() or "diagram"
        output_base_name = f"diagram_{output_base_name_safe[:40]}_{int(time.time())}" # Add timestamp for uniqueness

        image_path = self.render_scene_to_png(scene, output_base_name)

        if image_path and os.path.exists(image_path):
            print(f"ManimGen: Successfully generated Manim diagram at: {image_path}")
            return image_path
        else:
            print("ManimGen: Failed to render Manim diagram.")
            return None

    def cleanup_temp_dir(self):
        """Removes the persistent temporary directory used for Manim output."""
        if self.temp_dir and os.path.exists(self.temp_dir):
            print(f"ManimGen: Cleaning up temporary directory: {self.temp_dir}")
            try:
                shutil.rmtree(self.temp_dir)
                print("ManimGen: Cleanup complete.")
            except Exception as e:
                print(f"ManimGen: Error during cleanup of {self.temp_dir}: {e}")
            self.temp_dir = None

# Note: Example Usage (__main__) removed as this is a core class.
# Cleanup should ideally be called when your main application finishes,
# e.g., using a try/finally block or Streamlit's on_session_end callback if applicable.